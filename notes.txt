Revisar:

-Lo mas importante y que puede afectar la inferencia es lo de type builder,
la seccion que annade los metodos de string y object

-por que cuando hay dos variables con un mismo nombre en el let no nos quedamos con la ultima?
(probar otros casos de ese archivo let)

text = '''
    class A {
        b : AUTO_TYPE ;
        a : AUTO_TYPE ;

        f ( ) : Int { {
            let x : String , x : AUTO_TYPE <- a + b in x ;
        } } ;
    } ;
    
'''

En este caso si lo hace, porque no da error antes con que lo que se devuelve no se conforma:
class A {
        b : AUTO_TYPE ;
        a : AUTO_TYPE ;
       d : AUTO_TYPE ;

        f ( ) : Int { {
            d <- let x : String,  x : AUTO_TYPE <- a + b , self : AUTO_TYPE , x : AUTO_TYPE <- let c : AUTO_TYPE in a in x ;
       a;
        } } ;
    } ;

En este tambien porque el tipo de retorno no esta definido explicitamente:

class A {
        b : AUTO_TYPE ;
        a : AUTO_TYPE ;

        f ( ) : AUTO_TYPE { {
            let x : String , x : AUTO_TYPE <- a + b , self : AUTO_TYPE , x : AUTO_TYPE <- let c : AUTO_TYPE in a in x ;
        } } ;
    } ;

-Que hacemos con los void? Creo que deberian utilizarse para la inicializacion 
por default para casos como los de let(se dice que cuando no se provee inicializacion
se utiliza la de default de ese tipo)

-Que se espera con lo siguiente?:
se_jodio_el_self = '''
    class A {
        b : AUTO_TYPE ;
        a : AUTO_TYPE ;
        c : String ;
        f ( ) : Int { {
            case self of
                x : Int => x ;
                y : AUTO_TYPE => y ;
            esac ;
        } } ;
    } ;

-Esto no lo inferimos no? O sea b no se deduce int segun el tipo de retorno de f
class A {
        b : AUTO_TYPE ;
        a : AUTO_TYPE ;
        c : String ;
        f ( ) : Int { {
            b <- foo ( a ) ;
            b ;
        } } ;

        foo ( k : AUTO_TYPE ) : AUTO_TYPE { k <- a } ;
    } ;

-Esto siguiente da error por el tema de que en las clases que heredan no se ven los atributos del padre(Probar tambien los otros tres que viene atras en inference.txt de Carmita):

class B {
        k : AUTO_TYPE ;
    } ;

    class A inherits B {
        b : AUTO_TYPE ;
        a : AUTO_TYPE ;
        c : String ;
        f ( ) : Int { {
            b <- k + 1 ;
            b ;
        } } ;

        foo ( k : AUTO_TYPE ) : AUTO_TYPE { k <- a } ;
    } ;

-En este caso al final init no deberia ser POint en vez de selftype?:
class Point {
    x : AUTO_TYPE ;
    y : AUTO_TYPE ;
    init ( n : Int , m : Int ) : SELF_TYPE { {
        x <- n ;
        y <- m ; 
    } } ;
} ;

-Por que en el ejemplo siguiente main no devuekve Point?
class Point {
    succ ( n : AUTO_TYPE ) : AUTO_TYPE { n + 1 } ;
    translate ( n : AUTO_TYPE , m : AUTO_TYPE ) : SELF_TYPE { self } ;
} ;

class Main {
    step ( p : AUTO_TYPE ) : AUTO_TYPE { p . translate ( 1 , 1 ) } ;

    main ( ) : Object {
        let p : AUTO_TYPE <- new Point in {
            step ( p ) ; 
        }
    } ;
} ;

-Probar test1

-probar que no se joda con la herencia ciclica buscando eternamente por emtodos o 
atributos que no existen